<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lookup table</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #fff;
				color: #444;
			}
			a {
				color: red;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			webgl - lookup table<br />
			vertex color values from a range of data values
		</div>

		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import { GUI } from "three/addons/libs/lil-gui.module.min.js";

			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { Lut } from "three/addons/math/Lut.js";

			let container;

			let perpCamera, orthoCamera, renderer, lut;

			let mesh, sprite;
			let scene, uiScene;

			const params = {
				colorMap: "rainbow",
			};

			init();

			function init() {
				// è·å–å®¹å™¨
				container = document.getElementById("container");

				// åˆ›å»ºåœºæ™¯
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xffffff);

				// uiScene = new THREE.Scene();

				// çª—å£å®½é«˜
				const width = window.innerWidth;
				const height = window.innerHeight;

				// é€è§†ç›¸æœºï¼ˆæ‘„åƒæœºççœ¼è§’åº¦ï¼Œæ‘„åƒæœºè§†é”¥ä½“é•¿å®½æ¯”ï¼Œè¿‘ç«¯é¢ï¼Œè¿œç«¯é¢ï¼‰
				perpCamera = new THREE.PerspectiveCamera(60, width / height, 1, 100);
				// é»˜è®¤å³æ‰‹åæ ‡ç³»ï¼ˆç›¸æœºä½ç½®ï¼Œx,y,zï¼‰
				perpCamera.position.set(0, 0, 10);
				// perpCamera.position.set(0, 0, 1);
				scene.add(perpCamera);

				// æ­£äº¤ç›¸æœº
				// orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 2);
				// orthoCamera.position.set(0.5, 0, 1);

				// Lutå±äºThree.jsçš„Mathæ¨¡å—ï¼Œä¸»è¦æ–¹ä¾¿å¯¹æ¨¡å‹æŒ‰ç…§å¸¸è§é¢œè‰²æ–¹æ¡ˆè¿›è¡Œä¸Šè‰²ï¼Œé€‚ç”¨ç”¨äºäºŒç»´ã€ä¸‰ç»´çš„å›¾è¡¨ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§é¢œè‰²æ¡ã€‚
				lut = new Lut();

				// ç²¾çµæ˜¯ä¸€ä¸ªæ€»æ˜¯é¢æœç€æ‘„åƒæœºçš„å¹³é¢ï¼Œé€šå¸¸å«æœ‰ä½¿ç”¨ä¸€ä¸ªåŠé€æ˜çš„çº¹ç†ã€‚
				sprite = new THREE.Sprite(
					new THREE.SpriteMaterial({
						map: new THREE.CanvasTexture(lut.createCanvas()),
					})
				);
				// console.log(
				// 	"ğŸš€ --> file: webgl_geometry_colors_lookuptable.html:80 --> init --> sprite:",
				// 	sprite
				// );
				// sprite.material.map.colorSpace = THREE.SRGBColorSpace;
				// sprite.scale.x = 0.125;
				// uiScene.add( sprite );

				// ========================================

				// demo ç«‹æ–¹ä½“
				// const geometry1 = new THREE.BoxGeometry(1, 1, 1);
				// const material1 = new THREE.MeshBasicMaterial({ color: 0xffff00 });
				// const mesh1 = new THREE.Mesh(geometry1, material1);
				// scene.add(mesh1);

				// demo é¢ç‰‡
				// const geometry1 = new THREE.BufferGeometry();
				// // åˆ›å»ºä¸€ä¸ªç®€å•çš„çŸ©å½¢. åœ¨è¿™é‡Œæˆ‘ä»¬å·¦ä¸Šå’Œå³ä¸‹é¡¶ç‚¹è¢«å¤åˆ¶äº†ä¸¤æ¬¡ã€‚
				// // å› ä¸ºåœ¨ä¸¤ä¸ªä¸‰è§’é¢ç‰‡é‡Œï¼Œè¿™ä¸¤ä¸ªé¡¶ç‚¹éƒ½éœ€è¦è¢«ç”¨åˆ°ã€‚
				// const vertices = new Float32Array([
				// 	-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0,

				// 	1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0,
				// ]);

				// itemSize = 3 å› ä¸ºæ¯ä¸ªé¡¶ç‚¹éƒ½æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ã€‚
				// geometry1.setAttribute(
				// 	"position",
				// 	new THREE.BufferAttribute(vertices, 3)
				// );
				// const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
				// const mesh1 = new THREE.Mesh(geometry1, material1);
				// scene.add(mesh1);

				// ========================================

				// è¡¨ç¤ºåŸºäºä»¥ä¸‰è§’å½¢ä¸ºpolygon meshï¼ˆå¤šè¾¹å½¢ç½‘æ ¼ï¼‰çš„ç‰©ä½“çš„ç±»ã€‚
				mesh = new THREE.Mesh(
					undefined,
					new THREE.MeshLambertMaterial({
						side: THREE.DoubleSide,
						color: 0xf5f5f5,
						vertexColors: true,
					})
				);
				scene.add(mesh);

				// params = {
				// 	colorMap: "rainbow",
				// };

				loadModel();

				// ç‚¹å…‰æº
				const pointLight = new THREE.PointLight(0xffffff, 3, 0, 0);
				perpCamera.add(pointLight);

				// ç”¨WebGLæ¸²æŸ“å‡ºä½ ç²¾å¿ƒåˆ¶ä½œçš„åœºæ™¯ï¼Œæ¸²æŸ“å™¨(antialias trueå¼€å¯æŠ—é”¯é½¿ï¼Œé»˜è®¤false)
				renderer = new THREE.WebGLRenderer({ antialias: true });
				// renderer = new THREE.WebGLRenderer();

				// ä¸¤æ¬¡æˆ–å¤šæ¬¡æ‰§è¡Œæ¸²æŸ“æ–¹æ³•.render()å¾—åˆ°çš„åƒç´ æ•°æ®å åŠ 
				renderer.autoClear = false;
				// è®¾ç½®è®¾å¤‡åƒç´ æ¯”
				renderer.setPixelRatio(window.devicePixelRatio);
				// å°†è¾“å‡ºcanvasçš„å¤§å°è°ƒæ•´ä¸º(width, height)å¹¶è€ƒè™‘è®¾å¤‡åƒç´ æ¯”
				renderer.setSize(width, height);

				// console.log(
				// 	"ğŸš€ --> file: webgl_geometry_colors_lookuptable.html:161 --> init --> renderer:",
				// 	renderer
				// );

				container.appendChild(renderer.domElement);

				window.addEventListener("resize", onWindowResize);

				// const controls = new OrbitControls(perpCamera, renderer.domElement);
				// controls.addEventListener("change", render);

				// const gui = new GUI();

				// gui
				// 	.add(params, "colorMap", [
				// 		"rainbow",
				// 		"cooltowarm",
				// 		"blackbody",
				// 		"grayscale",
				// 	])
				// 	.onChange(function () {
				// 		updateColors();
				// 		render();
				// 	});
			}

			function loadModel() {
				const loader = new THREE.BufferGeometryLoader();

				loader.load("models/json/pressure.json", function (geometry) {
					// console.log(
					// 	"ğŸš€ --> file: webgl_geometry_colors_lookuptable.html:171 --> geometry:",
					// 	geometry
					// );
					// æ ¹æ®è¾¹ç•ŒçŸ©å½¢å°†å‡ ä½•ä½“å±…ä¸­
					geometry.center();
					// é€šè¿‡é¢ç‰‡æ³•å‘é‡çš„å¹³å‡å€¼è®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„æ³•å‘é‡ã€‚
					geometry.computeVertexNormals();

					// default color attribute
					const colors = [];

					for (let i = 0, n = geometry.attributes.position.count; i < n; ++i) {
						colors.push(1, 1, 1);
					}
					// console.log(
					// 	"ğŸš€ --> file: webgl_geometry_colors_lookuptable.html:209 --> colors:",
					// 	colors
					// );
					// console.log(
					// 	"ğŸš€ --> file: webgl_geometry_colors_lookuptable.html:205 --> geometry.attributes.position.count:",
					// 	geometry.attributes.position.count
					// );

					geometry.setAttribute(
						"color",
						new THREE.Float32BufferAttribute(colors, 3)
					);

					mesh.geometry = geometry;
					updateColors();

					render();
				});
			}

			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;

				perpCamera.aspect = width / height;
				perpCamera.updateProjectionMatrix();

				renderer.setSize(width, height);
				render();
			}

			function render() {
				renderer.clear();
				renderer.render(scene, perpCamera);
				// renderer.render(uiScene, orthoCamera);
			}

			function updateColors() {
				lut.setColorMap(params.colorMap);

				lut.setMax(2000);
				lut.setMin(0);

				const geometry = mesh.geometry;
				const pressures = geometry.attributes.pressure;
				const colors = geometry.attributes.color;
				const color = new THREE.Color();

				for (let i = 0; i < pressures.array.length; i++) {
					const colorValue = pressures.array[i];

					color.copy(lut.getColor(colorValue)).convertSRGBToLinear();

					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;

				const map = sprite.material.map;
				lut.updateCanvas(map.image);
				map.needsUpdate = true;
			}
		</script>
	</body>
</html>
